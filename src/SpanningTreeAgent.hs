module SpanningTreeAgent where

import AgentUtils
import Drone
import Ensemble
import Env
import EnvView
import GraphOPRC
import Policy
import WorldState

import Data.Maybe
import Data.Monoid
import qualified Data.Set as Set
import qualified Data.Map as Map
import System.Random


--this policy explores a spanning tree that minimizes covering old ground
data LowSpanningTreePolicy = LowSpanningTreePolicy (Map.Map Drone Directions)

initializeLSTP :: WorldView -> LowSpanningTreePolicy
initializeLSTP wv@(WorldView envInfo enStat) = LowSpanningTreePolicy $ Map.fromSet (const [MoveVertical Descend, Hover]) dronesList
  where
    dronesList :: Set.Set Drone
    dronesList = Set.fromList $ fmap fst enStat

instance Policy LowSpanningTreePolicy where
  nextMove p@(LowSpanningTreePolicy map) wv@(WorldView envInfo enStat) =
    if (null unassignedDrones)
      then ([], p)--all of the drones are acting, so no computation of next moves is necessary
      else assignMoves enStat directionsMap --make sure all drones have directions queued, then assign from their directions

    where
      unassignedDrones = needsCommand enStat

      --go through the map and make sure that all drones have a non empty list of actions to perform
      directionsMap = Map.mapWithKey lowerIfNeeded $ Map.mapWithKey (supplyDirections envInfo enStat) map

      lowerIfNeeded drone directions =
        if isHigh
          then (MoveVertical Descend) : directions
          else directions
        where
          isHigh = case (lookup drone alts) of
            Just High -> True
            _ -> False

          alts = fmap (fmap $ getEnvAlt . posFromStat) $ enStat

      --are there any drones for which no additional actions have been pre-computed?
      anyDronesLackingDirs = getAny $ foldMap (\dirs -> Any $ null dirs) map

assignMoves :: EnsembleStatus -> Map.Map Drone Directions -> (NextActions, LowSpanningTreePolicy)
assignMoves enStat map = (nextActions, LowSpanningTreePolicy newMap)
  where
    (nextActions, newMap) = Map.foldrWithKey accumulateMovesAndMap ([], Map.empty) map
    accumulateMovesAndMap drone directions (naSoFar, newMapSoFar) = (newNA, newMap)
      where
        newNA = (drone, head directions) : naSoFar
        newMap = Map.insert drone (tail directions) newMapSoFar


--use spanning forest based path generation to give directions to a drone if it lacks them
supplyDirections :: EnvironmentInfo -> EnsembleStatus -> Drone -> Directions -> Directions
supplyDirections _ _ _ dirs@(dir : more) = dirs --don't need to add directions if the drone already has some to follow
supplyDirections envInfo enStat drone [] = 
  if (null needsVisit)
    then [Hover]
    else case newDirections of
      Nothing -> [Hover]
      Just dirs -> dirs
  where
  --figure out the footprint of places worth visiting
  needsVisit = incompleteLocations envInfo
  minLoc = Set.findMin needsVisit

  --figure out which of those is closest to the drone's current position
  currentStatus = lookup drone enStat
  currentGroundPos = fmap groundPos currentStatus
  closestPos = case currentGroundPos of
    Nothing -> minLoc
    Just pos -> foldr (closerTo pos) minLoc needsVisit

  --pass that footprint to the spanning forest path creation function
  sfPath = customRootInBoundsSpanningTreePath 2 needsVisit closestPos

  --fill in all non-atomic gaps in that path with A*, including the path from current drone position to root
  atomicPath = toAtomicPath (Map.keysSet envInfo) closestPos sfPath --use the full footprint so that it has access to the full bounds

  --convert that path to directions
  newDirections = atomicPath >>= makeDirections

toAtomicPath :: Footprint -> Position -> Path -> Maybe Path
toAtomicPath fp startPos waypoints = fmap ((:) startPos) tailPath
  where
    tailPath = toAtomicPathInternal fp startPos waypoints

--takes the waypoints generated by spanning forest traversals and fills in the details, connecting it to a start position
toAtomicPathInternal :: Footprint -> Position -> Path -> Maybe Path
toAtomicPathInternal fp startPos [] = Just []
toAtomicPathInternal fp startPos (waypoint : more) =
  case (firstStep) of
    Nothing -> Nothing
    Just path -> fmap ((++) path) $ toAtomicPathInternal fp waypoint more
  where
    --fmap tail means that startPos does not get included in the path. 
    --Having this behavior in the recursive step makes it easier to combine outputs
    --startPos needs to be included if it is the actual top level start position
    firstStep = fmap tail $ aStarByFootprint fp mkManhattanHeuristic startPos waypoint

data LowKMeansSpanningTreePolicy = LowKMeansSpanningTreePolicy StdGen (Map.Map DroneTerritory Footprint)

instance Policy LowKMeansSpanningTreePolicy where
  nextMove p@(LowKMeansSpanningTreePolicy gen map) wv@(WorldView envInfo enStat) = applyMoves enStat gen2 directedMap

    where
      --directedMap must ensure that all drones are either acting or have a list of next actions to draw from
      directedMap = assignDirections setDirectionsBySpanningPath wv reassignedMap

      --opportunity to run kMeansInternal here, as in KMeansLowPolicy. Should I be doing this every time?
      reassignedMap = kMeansInternal incompleteLocations gen1 envInfo 1 map 
      (gen1, gen2) = split gen

instance DroneTerritoryMapPolicy LowKMeansSpanningTreePolicy where
  getMap (LowKMeansSpanningTreePolicy gen map) = map
  fromMap = LowKMeansSpanningTreePolicy

--the second parameter, meansSet, was useful for ShapeSweepAgent to prioritize exploring territory that was far from all other territory means
  --it is probably useful here as well, but I won't use it for now
setDirectionsBySpanningPath :: WorldView -> Set.Set DroneTerritory -> DroneTerritory -> Footprint -> DroneTerritory
setDirectionsBySpanningPath wv@(WorldView envInfo enStat) meansSet dt@(DroneTerritory drone mean dirs) fp =
  if (droneIsIdle && outOfDirections)
    then undefined
    else dt

  where
    --these 3 definitions determine whether the drone being considered needs a new set of directions at all
    droneStat = fromJust $ lookup drone enStat
    droneIsIdle = isUnassigned droneStat
    outOfDirections =
      case dirs of
        (action : actions) -> False
        [] -> True

    

--probably makes sense to create a function that explores all high then all low for now
data HighFirstSpanningTreePolicy = HighFirstSpanningTreePolicy (Map.Map DronePhase Directions)
--data HighFirstSpanningTreePolicy = HighFirstSpanningTreePolicy (Map.Map DroneTerritory Directions) (Map.Map Drone SweepPhase)

-- write code that "cleans up" after KMeans by reassigning individual patches to the drone that will be traversin its center. 
-- But can I know which drone that will be if I make the alignment of the spanning trees custoizable and adaptive?